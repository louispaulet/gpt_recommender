# -*- coding: utf-8 -*-
"""youtube channel recommendations.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rc-Kc4CKfrn0ouU4jZ7fv_uEfqeZmrHR

## install libs
"""

!pip install openai pydantic pandas

"""## load dataset"""

import pandas as pd

# Replace with your uploaded CSV filename
df = pd.read_csv("youtube_subscriptions_content_section.csv")
display(df.head())

"""## define functions

### output structure
"""

from pydantic import BaseModel, Field, ValidationError
from typing import List

class ChannelRecommendation(BaseModel):
    name: str = Field(..., description="The name of the recommended YouTube channel")
    url: str = Field(..., description="The full URL of the channel")
    short_description: str = Field(..., description="One-line description of the channel's theme")

class Recommendations(BaseModel):
    recommendations: List[ChannelRecommendation]

"""### craft prompt"""

def build_prompt(df, N=10):
    subscribed = list(zip(df['Channel Name'], df['Channel URL']))
    prompt = (
        "I am subscribed to the following YouTube channels (name and link):\n"
        + "\n".join(f"- {name}: {url}" for name, url in subscribed)
        + f"\n\nSuggest {N} new YouTube channels (not already in my subscriptions) that I might like, "
          "in JSON format with the following structure:\n"
          "{'recommendations': ["
          "{'name': str, 'url': str, 'short_description': str}, ...]}"
    )
    return prompt

print(build_prompt(df, 5))

"""### call openai with prompt"""

from google.colab import userdata
api_key = userdata.get('OPENAI_API_KEY')

import openai

# api_key = "YOUR_OPENAI_API_KEY"  # Replace with your actual key
openai.api_key = api_key

prompt = build_prompt(df, N=10)
model = "gpt-4.1-mini-2025-04-14"  # or "gpt-4o" or "gpt-4-0125-preview", adjust as needed

response = openai.chat.completions.create(
    model=model,
    messages=[{"role": "user", "content": prompt}],
    response_format={"type": "json_object"},  # Enables JSON mode
    temperature=0.6,
)

response_json = response.choices[0].message.content
print(response_json)

"""### filter 404 channels"""

import json
import requests
from typing import List, Dict

def filter_non_404_channels(channels: List[Dict]) -> List[Dict]:
    """
    Returns a new list of channels where the channel URL does not return a 404 error.
    Performs a HEAD request to check the existence of each URL.
    """
    valid_channels = []
    for channel in channels:
        url = channel.get("url")
        try:
            # Use HEAD for efficiency, fallback to GET if HEAD is not allowed
            response = requests.head(url, allow_redirects=True, timeout=5)
            if response.status_code == 404:
                continue
            # Some sites don't allow HEAD; try GET if 405 Method Not Allowed
            if response.status_code == 405:
                response = requests.get(url, allow_redirects=True, timeout=5)
                if response.status_code == 404:
                    continue
            # All good, keep this channel
            valid_channels.append(channel)
        except requests.RequestException:
            # On network errors or timeouts, skip this channel
            continue
    return valid_channels

# Usage example with your data:
filtered = filter_non_404_channels(response_json["recommendations"])
print(json.dumps(filtered, indent=2, ensure_ascii=False))

"""## run the recommendation end to end"""

response = openai.chat.completions.create(
    model=model,
    messages=[{"role": "user", "content": prompt}],
    response_format={"type": "json_object"},  # Enables JSON mode
    temperature=0.6,
)

response_json = json.loads(response.choices[0].message.content)
filtered = filter_non_404_channels(response_json["recommendations"])
print(json.dumps(filtered, indent=2, ensure_ascii=False))

response = openai.chat.completions.create(
    model=model,
    messages=[{"role": "user", "content": prompt}],
    response_format={"type": "json_object"},  # Enables JSON mode
    temperature=0.6,
)
response_json = json.loads(response.choices[0].message.content)
filtered = filter_non_404_channels(response_json["recommendations"])
print(json.dumps(filtered, indent=2, ensure_ascii=False))

"""## Use tool calling

### check if channel is already subscribed
"""

model

subscriptions = df.to_dict("records")

subscriptions

# !pip install openai requests

import openai
import requests
import json
import time

OPENAI_API_KEY = api_key

# --- subscriptions = [...] # Assume already in your notebook

def check_already_subscribed(Channel_Name: str, Channel_URL: str) -> dict:
    name_lower = Channel_Name.strip().lower()
    url_lower = Channel_URL.strip().lower()
    for sub in subscriptions:
        if name_lower == sub['Channel Name'].strip().lower() or url_lower == sub['Channel URL'].strip().lower():
            return {"result": True}
    return {"result": False}

def check_channel_exists(Channel_URL: str) -> dict:
    try:
        r = requests.head(Channel_URL, allow_redirects=True, timeout=5)
        if r.status_code == 404:
            return {"result": False}
        if r.status_code == 405:
            r = requests.get(Channel_URL, allow_redirects=True, timeout=5)
            if r.status_code == 404:
                return {"result": False}
        return {"result": True}
    except Exception:
        return {"result": False}

tools = [
    {
        "type": "function",
        "function": {
            "name": "check_already_subscribed",
            "description": "Return True if the channel is already in the user's subscriptions.",
            "parameters": {
                "type": "object",
                "properties": {
                    "Channel Name": {"type": "string"},
                    "Channel URL": {"type": "string"},
                },
                "required": ["Channel Name", "Channel URL"],
                "additionalProperties": False
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "check_channel_exists",
            "description": "Return True if the channel URL does NOT return 404.",
            "parameters": {
                "type": "object",
                "properties": {
                    "Channel URL": {"type": "string"}
                },
                "required": ["Channel URL"],
                "additionalProperties": False
            }
        }
    }
]

subs_text = "\n".join(f"- {sub['Channel Name']}: {sub['Channel URL']}" for sub in subscriptions)
prompt = (
    f"Here are my current YouTube subscriptions (Channel Name and Channel URL):\n{subs_text}\n\n"
    f"Please recommend 10 new YouTube channels I might like. "
    "For each recommendation, use the provided tools to check if I am already subscribed (by 'Channel Name' or 'Channel URL'), "
    "and to check if the 'Channel URL' exists (not 404). "
    "Only recommend channels for which both checks pass. "
    "Return your answer as a JSON object under the key 'recommendations', with each recommendation using the keys 'Channel Name', 'Channel URL', and 'short_description'."
)

client = openai.OpenAI(api_key=OPENAI_API_KEY)
messages = [{"role": "user", "content": prompt}]
tool_map = {
    "check_already_subscribed": check_already_subscribed,
    "check_channel_exists": check_channel_exists
}

while True:
    response = client.chat.completions.create(
        model="gpt-4.1-mini-2025-04-14",
        input=messages,
        tools=tools,
        response_format={"type": "json_object"},
        max_tokens=2048,
    )
    msg = response.choices[0].message

    # Tool calls
    if msg.tool_calls:
        for tool_call in msg.tool_calls:
            fn = tool_map[tool_call.function.name]
            args = json.loads(tool_call.function.arguments)
            result = fn(**args)
            messages.append({
                "role": "tool",
                "tool_call_id": tool_call.id,
                "name": tool_call.function.name,
                "content": json.dumps(result),
            })
        continue

    # Final answer (JSON object)
    if msg.content:
        try:
            answer = json.loads(msg.content)
            recommendations = answer.get("recommendations", answer)
            print(json.dumps(recommendations, indent=2, ensure_ascii=False))
        except Exception:
            print(msg.content)
        break